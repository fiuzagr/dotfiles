#!/usr/bin/env sh

set -e

LLM_VERSION="1.0.0"
LLM_DEFAULT_MODEL="anthropic/claude-opus-4.5"
LLM_API_URL="https://openrouter.ai/api/v1/chat/completions"
LLM_HISTORY_DIR="$HOME/.local/share/llm"
LLM_HISTORY_FILE="$LLM_HISTORY_DIR/history.log"

llm_show_usage() {
  cat <<EOF
Version: $LLM_VERSION
Usage: llm [--debug] "natural language description"

Convert natural language to shell commands using OpenRouter API.

Requirements:
  jq                   Required. JSON processor (install via brew/apt)

Options:
  --debug    Show debug information including request payload and API responses

Environment variables:
  OPENROUTER_API_KEY  Required. Your OpenRouter API key
  OPENROUTER_MODEL    Optional. Model to use (default: $LLM_DEFAULT_MODEL)
  LLM_DEBUG           Optional. Set to '1' to enable debug mode

Examples:
  llm "find files modified in last 24 hours"
  llm --debug "list the 10 largest files in current directory"
  llm "kill the process using port 3000"
EOF
}

llm_check_dependencies() {
  if ! command -v jq >/dev/null 2>&1; then
    echo "Error: jq is required but not installed" >&2
    echo "" >&2
    echo "Install with:" >&2
    echo "  macOS:   brew install jq" >&2
    echo "  Linux:   apt install jq / dnf install jq" >&2
    exit 1
  fi
}

llm_check_api_key() {
  if [ -z "$OPENROUTER_API_KEY" ]; then
    echo "Error: OPENROUTER_API_KEY is not set" >&2
    echo "" >&2
    echo "Get your API key at: https://openrouter.ai/keys" >&2
    echo "Then export it: export OPENROUTER_API_KEY='your-key-here'" >&2
    exit 1
  fi
}

llm_get_model() {
  if [ -n "$OPENROUTER_MODEL" ]; then
    echo "$OPENROUTER_MODEL"
  else
    echo "$LLM_DEFAULT_MODEL"
  fi
}

llm_get_os() {
  case "$(uname -s)" in
  Darwin*) echo "macOS" ;;
  Linux*) echo "Linux" ;;
  *) echo "unknown" ;;
  esac
}

llm_get_shell() {
  case "$SHELL" in
  *zsh) echo "zsh" ;;
  *bash) echo "bash" ;;
  *) echo "sh" ;;
  esac
}

llm_build_system_prompt() {
  lbs_os=$(llm_get_os)
  lbs_shell=$(llm_get_shell)

  # Retornar JSON-escaped string
  printf '%s' "You are a shell command generator. Convert the user's natural language request into a single, executable shell command.\\n\\nEnvironment:\\n- Operating System: $lbs_os\\n- Current Shell: $lbs_shell\\n\\nRules:\\n- Output ONLY the command, no explanations or markdown\\n- Use POSIX-compliant syntax compatible with $lbs_shell\\n- For macOS: use BSD-compatible syntax (e.g., sed -i '\\\\' not sed -i)\\n- For Linux: use GNU syntax\\n- Prefer standard Unix tools (find, grep, sed, awk)\\n- If multiple commands needed, use && or ; to chain\\n- Quote variables and paths with spaces\\n- Be safe: avoid destructive operations without clear intent\\n\\nExamples:\\nRequest: \\\"find large files over 100MB\\\"\\nOutput: find . -type f -size +100M -exec ls -lh {} ;\\n\\nRequest: \\\"kill process on port 3000\\\"\\nOutput: lsof -ti:3000 | xargs kill -9\\n\\nRequest: \\\"count lines in all python files\\\"\\nOutput: find . -name \\\"*.py\\\" -exec wc -l {} + | awk '{sum+=\\\$1} END {print sum}'"
}

llm_call_api() {
  lca_prompt="$1"
  lca_model=$(llm_get_model)
  lca_system_prompt=$(llm_build_system_prompt)

  # Escapar apenas aspas e backslashes no user prompt
  lca_prompt_escaped=$(printf '%s' "$lca_prompt" | sed 's/\\/\\\\/g; s/"/\\"/g')

  # Construir JSON completo diretamente no heredoc
  lca_payload=$(
    cat <<EOF
{
  "model": "$lca_model",
  "messages": [
    {
      "role": "system",
      "content": "$lca_system_prompt"
    },
    {
      "role": "user",
      "content": "$lca_prompt_escaped"
    }
  ]
}
EOF
  )

  if [ "$LLM_DEBUG" = "1" ]; then
    printf "${LLM_CYAN}DEBUG JSON payload:${LLM_NC}\n%s\n\n" "$lca_payload" >&2
  fi

  curl -s -w "\n%{http_code}" "$LLM_API_URL" \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $OPENROUTER_API_KEY" \
    -d "$lca_payload" 2>/dev/null
}

llm_sanitize_json() {
  tr -d '\n\r' | sed 's/\\;/\\\\;/g; s/\\(/\\\\(/g; s/\\)/\\\\)/g'
}

llm_extract_command() {
  lec_response="$1"

  lec_content=$(printf '%s' "$lec_response" | llm_sanitize_json | jq -r '.choices[0].message.content // empty')

  if [ -z "$lec_content" ]; then
    return 1
  fi

  echo "$lec_content"
}

llm_clean_command() {
  lcc_raw="$1"

  lcc_cmd=$(echo "$lcc_raw" | sed 's/```bash//g' | sed 's/```sh//g' | sed 's/```shell//g' | sed 's/```//g')

  lcc_cmd=$(echo "$lcc_cmd" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

  lcc_cmd=$(echo "$lcc_cmd" | grep -v '^$' | head -1)

  echo "$lcc_cmd"
}

llm_copy_to_clipboard() {
  if command -v pbcopy >/dev/null 2>&1; then
    echo "$1" | pbcopy
    return 0
  elif command -v xclip >/dev/null 2>&1; then
    echo "$1" | xclip -selection clipboard
    return 0
  elif command -v xsel >/dev/null 2>&1; then
    echo "$1" | xsel --clipboard --input
    return 0
  else
    return 1
  fi
}

llm_log_history() {
  llh_request="$1"
  llh_command="$2"
  llh_action="$3"

  if [ ! -d "$LLM_HISTORY_DIR" ]; then
    mkdir -p "$LLM_HISTORY_DIR" 2>/dev/null || return 1
  fi

  llh_timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  echo "${llh_timestamp}|${llh_request}|${llh_command}|${llh_action}" >>"$LLM_HISTORY_FILE" 2>/dev/null
}

llm_show_colors() {
  if [ -t 1 ]; then
    LLM_RED='\033[0;31m'
    LLM_GREEN='\033[0;32m'
    LLM_YELLOW='\033[1;33m'
    LLM_BLUE='\033[0;34m'
    LLM_CYAN='\033[0;36m'
    LLM_NC='\033[0m'
  else
    LLM_RED=''
    LLM_GREEN=''
    LLM_YELLOW=''
    LLM_BLUE=''
    LLM_CYAN=''
    LLM_NC=''
  fi
}

main() {
  # Parse options
  if [ "$1" = "--debug" ]; then
    LLM_DEBUG=1
    export LLM_DEBUG
    shift
  fi

  if [ $# -eq 0 ]; then
    llm_show_usage
    exit 1
  fi

  llm_show_colors

  llm_check_dependencies
  llm_check_api_key

  lpm_user_input="$*"

  printf "${LLM_BLUE}Request:${LLM_NC} %s\n" "$lpm_user_input"
  printf "${LLM_YELLOW}Generating command...${LLM_NC}\n"

  lpm_api_response=$(llm_call_api "$lpm_user_input")

  lpm_http_code=$(echo "$lpm_api_response" | tail -1)
  lpm_response_body=$(echo "$lpm_api_response" | sed '$d')

  if [ "$LLM_DEBUG" = "1" ] && [ -n "$lpm_response_body" ]; then
    printf "${LLM_RED}Response: %s${LLM_NC}\n" "$lpm_response_body" >&2
  fi

  case "$lpm_http_code" in
  200) ;;
  400)
    printf "${LLM_RED}Error: Bad request (HTTP %s)${LLM_NC}\n" "$lpm_http_code" >&2
    printf "${LLM_RED}Check your model name and ensure all parameters are valid.${LLM_NC}\n" >&2
    exit 1
    ;;
  401)
    printf "${LLM_RED}Error: Invalid API key (HTTP %s)${LLM_NC}\n" "$lpm_http_code" >&2
    printf "${LLM_RED}Check your OPENROUTER_API_KEY is valid.${LLM_NC}\n" >&2
    exit 1
    ;;
  429)
    printf "${LLM_RED}Error: Rate limit exceeded (HTTP %s)${LLM_NC}\n" "$lpm_http_code" >&2
    printf "${LLM_RED}Please wait and try again${LLM_NC}\n" >&2
    exit 1
    ;;
  5XX)
    printf "${LLM_RED}Error: Server error (HTTP %s)${LLM_NC}\n" "$lpm_http_code" >&2
    printf "${LLM_RED}Try again later or check OpenRouter status.${LLM_NC}\n" >&2
    exit 1
    ;;
  *)
    printf "${LLM_RED}Error: API request failed (HTTP %s)${LLM_NC}\n" "$lpm_http_code" >&2
    exit 1
    ;;
  esac

  lpm_raw_command=$(llm_extract_command "$lpm_response_body")

  if [ -z "$lpm_raw_command" ]; then
    printf "${LLM_RED}Error: No command generated${LLM_NC}\n" >&2
    exit 1
  fi

  lpm_command=$(llm_clean_command "$lpm_raw_command")

  if [ -z "$lpm_command" ]; then
    printf "${LLM_RED}Error: Failed to parse command from response${LLM_NC}\n" >&2
    exit 1
  fi

  printf "\n${LLM_GREEN}Generated command:${LLM_NC}\n"
  printf "  ${LLM_CYAN}%s${LLM_NC}\n" "$lpm_command"
  printf "\n"
  printf "Execute this command? [y]es, [c]opy, [n]o: "
  read -r lpm_choice

  case "$lpm_choice" in
  y | Y | "")
    printf "${LLM_BLUE}Executing...${LLM_NC}\n"
    printf "${LLM_YELLOW}----------------------------------------${LLM_NC}\n"
    eval "$lpm_command"
    lpm_exit_code=$?
    printf "${LLM_YELLOW}----------------------------------------${LLM_NC}\n"
    if [ $lpm_exit_code -eq 0 ]; then
      printf "${LLM_GREEN}Command completed successfully${LLM_NC}\n"
    else
      printf "${LLM_RED}Command exited with code %s${LLM_NC}\n" "$lpm_exit_code"
    fi
    llm_log_history "$lpm_user_input" "$lpm_command" "executed"
    ;;
  c | C)
    if llm_copy_to_clipboard "$lpm_command"; then
      printf "${LLM_GREEN}Command copied to clipboard${LLM_NC}\n"
    else
      printf "${LLM_YELLOW}Clipboard not available. Command:${LLM_NC}\n"
      printf "  %s\n" "$lpm_command"
    fi
    llm_log_history "$lpm_user_input" "$lpm_command" "copied"
    ;;
  n | N | q | Q)
    printf "${LLM_YELLOW}Command cancelled${LLM_NC}\n"
    llm_log_history "$lpm_user_input" "$lpm_command" "cancelled"
    ;;
  *)
    printf "${LLM_YELLOW}Invalid choice. Command cancelled.${LLM_NC}\n"
    llm_log_history "$lpm_user_input" "$lpm_command" "cancelled"
    ;;
  esac
}

main "$@"
